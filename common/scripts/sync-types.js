#!/usr/bin/env node

/**
 * Enhanced Type Synchronization Script
 * 
 * This script ensures the common/src/types/api.ts file remains the single source of truth
 * for API types. It:
 * 1. Preserves manually defined types in api.ts
 * 2. Adds any new types found in the OpenAPI schema
 * 3. Updates type definitions if schemas have changed
 * 
 * This ensures we maintain DRY principles while allowing for proper documentation
 * and manual type refinements when needed.
 */

import fs from 'fs';
import path from 'path';
import ts from 'typescript';
import YAML from 'yamljs';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Paths
const schemaJsonPath = path.join(__dirname, '../src/schema/swagger.json');
const schemaYamlPath = path.join(__dirname, '../src/schema/swagger.yaml');
const apiTypesPath = path.join(__dirname, '../src/types/api.ts');

// Ensure directory exists
const apiTypesDir = path.dirname(apiTypesPath);
if (!fs.existsSync(apiTypesDir)) {
  fs.mkdirSync(apiTypesDir, { recursive: true });
}

// Helper function to parse existing TypeScript interfaces
function parseExistingTypes(filePath) {
  if (!fs.existsSync(filePath)) {
    return new Map();
  }

  const content = fs.readFileSync(filePath, 'utf8');
  const sourceFile = ts.createSourceFile(
    filePath,
    content,
    ts.ScriptTarget.Latest,
    true
  );

  const interfaces = new Map();
  
  function visit(node) {
    if (ts.isInterfaceDeclaration(node)) {
      interfaces.set(node.name.text, {
        name: node.name.text,
        text: content.substring(node.pos, node.end)
      });
    }
    ts.forEachChild(node, visit);
  }
  
  visit(sourceFile);
  return interfaces;
}

// Read the generated schema (JSON or YAML)
try {
  let schema;
  
  // Try to read schema from JSON first, then YAML if JSON doesn't exist
  if (fs.existsSync(schemaJsonPath)) {
    console.log('üìÑ Found swagger.json, using it for type generation');
    const schemaContent = fs.readFileSync(schemaJsonPath, 'utf-8');
    schema = JSON.parse(schemaContent);
  } else if (fs.existsSync(schemaYamlPath)) {
    console.log('üìÑ Found swagger.yaml, converting to JSON for type generation');
    schema = YAML.load(schemaYamlPath);
    
    // Optionally write the JSON version for future use
    fs.writeFileSync(schemaJsonPath, JSON.stringify(schema, null, 2));
    console.log('üíæ Created swagger.json from YAML for future use');
  } else {
    console.error('‚ùå Error: No schema file found. Run generate-api-types.sh first.');
    process.exit(1);
  }

  // Extract the components/schemas section
  const schemas = schema.components?.schemas || {};
  
  // Parse existing API types
  const existingTypes = parseExistingTypes(apiTypesPath);
  
  // Generate header with imports and initial types
  let output = `/**
 * API Types
 * 
 * This is the single source of truth for all API types used in Discura.
 * These types are used by both the frontend and backend.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY unless adding types that will be used
 * by TSOA controllers for schema generation.
 */

import { Bot, BotStatus as BotStatusEnum, LLMProvider } from './index';

`;

  // Preserve existing manually defined types (if they exist)
  existingTypes.forEach((typeInfo, typeName) => {
    output += typeInfo.text + '\n\n';
  });

  // Process schemas to create TypeScript interfaces for types not manually defined
  for (const [name, schema] of Object.entries(schemas)) {
    // Skip if we already have this interface defined manually
    if (existingTypes.has(name)) {
      continue;
    }
    
    output += `export interface ${name} {\n`;
    
    if (schema.properties) {
      for (const [propName, propData] of Object.entries(schema.properties)) {
        const isRequired = schema.required?.includes(propName) ? '' : '?';
        let typeName = 'any';
        
        // Determine the TypeScript type based on the schema type
        switch (propData.type) {
          case 'string':
            // Special case for status fields that should use BotStatusEnum
            if (propName === 'status') {
              typeName = 'BotStatusEnum';
            } else {
              typeName = 'string';
            }
            break;
          case 'number':
            typeName = 'number';
            break;
          case 'boolean':
            typeName = 'boolean';
            break;
          case 'integer':
            typeName = 'number';
            break;
          case 'array':
            if (propData.items?.type) {
              typeName = `${propData.items.type}[]`;
            } else if (propData.items?.$ref) {
              const refType = propData.items.$ref.split('/').pop();
              typeName = `${refType}[]`;
            } else {
              typeName = 'any[]';
            }
            break;
          case 'object':
            typeName = 'Record<string, any>';
            break;
          default:
            // Handle $ref type
            if (propData.$ref) {
              typeName = propData.$ref.split('/').pop();
            }
        }
        
        output += `  ${propName}${isRequired}: ${typeName};\n`;
      }
    }
    
    output += '}\n\n';
  }

  // Write the output to the API types file
  fs.writeFileSync(apiTypesPath, output);
  console.log('‚úÖ API types synchronized successfully!');

} catch (error) {
  console.error('‚ùå Error syncing types:', error);
  process.exit(1);
}