#!/usr/bin/env node

/**
 * Type Synchronization Script
 *
 * This script ensures the common/src/schema/types.ts file remains the single source of truth
 * for API types. It:
 * 1. Reads types directly from the OpenAPI schema generated by TSOA controllers
 * 2. Generates TypeScript interfaces and enums based on the schema
 * 3. Creates a properly typed file for use throughout the application
 *
 * This adheres to the project guidelines where common/src/types/api is the source of truth
 * for API definitions, and no backend model definitions should exist.
 */

const fs = require("fs");
const path = require("path");
const YAML = require("yamljs");

// Paths
const schemaJsonPath = path.join(__dirname, "../src/schema/swagger.json");
const schemaYamlPath = path.join(__dirname, "../src/schema/swagger.yaml");
const schemaTypesPath = path.join(__dirname, "../src/schema/types.ts");
const bootstrapTypesPath = path.join(__dirname, "../src/schema/types.ts");

// Ensure directory exists
const schemaTypesDir = path.dirname(schemaTypesPath);
if (!fs.existsSync(schemaTypesDir)) {
  fs.mkdirSync(schemaTypesDir, { recursive: true });
}

// Helper function to read the bootstrap types file and extract types with their properties
function extractBootstrapTypes() {
  if (!fs.existsSync(bootstrapTypesPath)) {
    return {};
  }

  const content = fs.readFileSync(bootstrapTypesPath, "utf-8");
  const bootstrapTypes = {};

  // Extract interfaces
  const interfaceRegex = /export\s+interface\s+([A-Za-z0-9_]+)\s*{([^}]*)}/gs;
  let match;

  while ((match = interfaceRegex.exec(content)) !== null) {
    const name = match[1];
    const body = match[2];

    // Extract properties
    const properties = [];
    const propertyRegex = /\s*([A-Za-z0-9_]+)(\??)\s*:\s*([^;]+);/g;
    let propMatch;

    while ((propMatch = propertyRegex.exec(body)) !== null) {
      properties.push({
        name: propMatch[1],
        optional: !!propMatch[2],
        type: propMatch[3].trim(),
      });
    }

    bootstrapTypes[name] = {
      type: "interface",
      properties,
    };
  }

  // Extract enums
  const enumRegex = /export\s+enum\s+([A-Za-z0-9_]+)\s*{([^}]*)}/gs;

  while ((match = enumRegex.exec(content)) !== null) {
    const name = match[1];
    const body = match[2];

    // Extract values
    const values = [];
    const valueRegex = /\s*([A-Za-z0-9_]+)\s*=\s*["']([^"']+)["']/g;
    let valueMatch;

    while ((valueMatch = valueRegex.exec(body)) !== null) {
      values.push({
        name: valueMatch[1],
        value: valueMatch[2],
      });
    }

    bootstrapTypes[name] = {
      type: "enum",
      values,
    };
  }

  return bootstrapTypes;
}

try {
  // Read the generated schema (JSON or YAML)
  let schema;
  if (fs.existsSync(schemaJsonPath)) {
    console.log("üìÑ Found swagger.json, using it for type generation");
    const schemaContent = fs.readFileSync(schemaJsonPath, "utf-8");
    schema = JSON.parse(schemaContent);
  } else if (fs.existsSync(schemaYamlPath)) {
    console.log(
      "üìÑ Found swagger.yaml, converting to JSON for type generation"
    );
    schema = YAML.load(schemaYamlPath);
    fs.writeFileSync(schemaJsonPath, JSON.stringify(schema, null, 2));
    console.log("üíæ Created swagger.json from YAML for future use");
  } else {
    console.error(
      "‚ùå Error: No schema file found. Run generate-api-types.sh first."
    );
    process.exit(1);
  }

  // Extract schemas from OpenAPI spec
  const schemas = schema.components?.schemas || {};
  console.log("[sync-types.js] Found schemas:", Object.keys(schemas));

  // Load bootstrap types to use as fallbacks if schema definitions are incomplete
  const bootstrapTypes = extractBootstrapTypes();

  // Generate header with imports and initial types
  let output = `/**
 * API Types
 * 
 * This is the single source of truth for all API types used in Discura.
 * These types are generated from the OpenAPI schema (swagger.json)
 * which is derived from TSOA definitions in common/src/types/api.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Changes should be made in the source files in common/src/types/api, then run ./generate-api-types.sh
 */

`;

  // Map to keep track of Record types that need to be processed as TypeScript native Record types
  const recordTypeMap = new Map();

  // Helper function to detect Record types from TSOA generated names
  function detectRecordType(name) {
    // Simple Record type like Record_string.any_
    const simpleRecordMatch = name.match(/^Record_([^\.]+)\.([^_]+)_$/);
    if (simpleRecordMatch) {
      return {
        keyType: simpleRecordMatch[1],
        valueType: simpleRecordMatch[2],
        typeName: `Record<${simpleRecordMatch[1]}, ${simpleRecordMatch[2]}>`
      };
    }
    return null;
  }

  // First pass to identify all Record types
  for (const name of Object.keys(schemas)) {
    const recordType = detectRecordType(name);
    if (recordType) {
      // Store info for later use
      recordTypeMap.set(name, recordType);
    }
  }

  // Helper function to convert Record types in references
  function sanitizeTypeName(typeName) {
    if (recordTypeMap.has(typeName)) {
      return recordTypeMap.get(typeName).typeName;
    }
    return typeName;
  }

  // Helper function to determine if a schema seems incomplete
  function isIncompleteSchema(schemaData) {
    // Check if it's an empty object schema
    if (
      schemaData.type === "object" &&
      (!schemaData.properties ||
        Object.keys(schemaData.properties).length === 0)
    ) {
      return true;
    }

    // Check if it contains placeholders in its description
    if (
      schemaData.description &&
      schemaData.description.includes("Placeholder") &&
      schemaData.description.includes("will be replaced")
    ) {
      return true;
    }

    return false;
  }

  // Process schemas to create TypeScript interfaces and enums
  for (const [name, schemaData] of Object.entries(schemas)) {
    // If it's a Record type, generate a type alias instead of an interface
    if (recordTypeMap.has(name)) {
      const { keyType, valueType, typeName } = recordTypeMap.get(name);
      console.log(`[sync-types.js] Converting Record type: ${name} to ${typeName}`);
      
      const safeTypeName = name.replace(/\./g, '_');
      output += `// Generated from TSOA Record type: ${name}\n`;
      output += `export type ${safeTypeName} = ${typeName};\n\n`;
      continue;
    }

    // Check if the schema represents an enum (string type with an enum array)
    if (schemaData.type === "string" && Array.isArray(schemaData.enum)) {
      console.log(`[sync-types.js] Generating enum: ${name}`);
      output += `export enum ${name} {\n`;

      // Use schema enum values if available
      if (schemaData.enum.length > 0) {
        for (const enumValue of schemaData.enum) {
          let memberName = String(enumValue).toUpperCase();
          memberName = memberName.replace(/[^A-Z0-9_]/g, "_");
          const validMemberName = /^[A-Z_][A-Z0-9_]*$/.test(memberName)
            ? memberName
            : `_${memberName}`;
          output += `  ${validMemberName} = "${enumValue}",\n`;
        }
      }
      // Fall back to bootstrap enum values if schema is empty but bootstrap has values
      else if (
        bootstrapTypes[name] &&
        bootstrapTypes[name].type === "enum" &&
        bootstrapTypes[name].values.length > 0
      ) {
        console.log(`[sync-types.js] Using bootstrap values for enum ${name}`);
        for (const { name: valueName, value } of bootstrapTypes[name].values) {
          output += `  ${valueName} = "${value}",\n`;
        }
      }
      // Provide a default empty enum value as last resort
      else {
        output += `  // No enum values available\n`;
      }

      output += "}\n\n";
    } else if (schemaData.type === "object" || schemaData.properties) {
      console.log(`[sync-types.js] Generating interface: ${name}`);
      output += `export interface ${name} {\n`;

      // Check if the schema definition appears to be incomplete
      if (isIncompleteSchema(schemaData) && bootstrapTypes[name]) {
        // Use bootstrap properties if available
        console.log(
          `[sync-types.js] Schema for ${name} appears incomplete, using bootstrap properties`
        );

        if (
          bootstrapTypes[name].properties &&
          bootstrapTypes[name].properties.length > 0
        ) {
          for (const {
            name: propName,
            type: propType,
            optional,
          } of bootstrapTypes[name].properties) {
            if (propName !== "[key: string]") {
              // Skip generic index signature
              output += `  ${propName}${optional ? "?" : ""}: ${propType};\n`;
            }
          }
        } else {
          output += `  // No properties available in bootstrap\n`;
          output += `  [key: string]: any;\n`;
        }
      } else if (
        schemaData.properties &&
        Object.keys(schemaData.properties).length > 0
      ) {
        // Use schema properties when available
        for (const [propName, propData] of Object.entries(
          schemaData.properties
        )) {
          const isRequired = schemaData.required?.includes(propName) ? "" : "?";
          let typeName = "any";

          switch (propData.type) {
            case "string":
              typeName = "string";
              break;
            case "number":
              typeName = "number";
              break;
            case "boolean":
              typeName = "boolean";
              break;
            case "integer":
              typeName = "number";
              break;
            case "array":
              if (propData.items?.type) {
                typeName = `${propData.items.type}[]`;
              } else if (propData.items?.$ref) {
                const refType = propData.items.$ref.split("/").pop();
                typeName = `${sanitizeTypeName(refType)}[]`;
              } else {
                typeName = "any[]";
              }
              break;
            case "object":
              if (propData.additionalProperties) {
                let valueType = "any";
                if (propData.additionalProperties.type) {
                  valueType = propData.additionalProperties.type;
                } else if (propData.additionalProperties.$ref) {
                  valueType = propData.additionalProperties.$ref
                    .split("/")
                    .pop();
                }
                typeName = `Record<string, ${valueType}>`;
              } else {
                typeName = "Record<string, any>";
              }
              break;
            default:
              if (propData.$ref) {
                const refType = propData.$ref.split("/").pop();
                typeName = sanitizeTypeName(refType); 
              } else if (propData.enum) {
                typeName = propData.enum.map((v) => `"${v}"`).join(" | ");
              }
          }

          output += `  ${propName}${isRequired}: ${typeName};\n`;
        }
      } else {
        // If no properties are available even in bootstrap, create a generic index signature
        output += `  // No schema properties defined\n`;
        output += `  [key: string]: any;\n`;
      }

      output += "}\n\n";
    }
  }

  // Write the output to the API types file
  fs.writeFileSync(schemaTypesPath, output);
  console.log(
    "‚úÖ API types synchronized successfully to common/src/schema/types.ts!"
  );
} catch (error) {
  console.error("‚ùå Error syncing types:", error);
  console.error(error.stack);
  process.exit(1);
}
