#!/usr/bin/env node

/**
 * Type Synchronization Script
 * 
 * This script ensures the common/src/schema/types.ts file remains the single source of truth
 * for API types. It:
 * 1. Reads types directly from the OpenAPI schema generated by TSOA controllers
 * 2. Generates TypeScript interfaces and enums based on the schema
 * 3. Creates a properly typed file for use throughout the application
 * 
 * This adheres to the project guidelines where common/src/types/api is the source of truth
 * for API definitions, and no backend model definitions should exist.
 */

const fs = require('fs');
const path = require('path');
const YAML = require('yamljs');

// Paths
const schemaJsonPath = path.join(__dirname, '../src/schema/swagger.json');
const schemaYamlPath = path.join(__dirname, '../src/schema/swagger.yaml');
const schemaTypesPath = path.join(__dirname, '../src/schema/types.ts');
const bootstrapTypesPath = path.join(__dirname, '../src/schema/types.ts');

// Ensure directory exists
const schemaTypesDir = path.dirname(schemaTypesPath);
if (!fs.existsSync(schemaTypesDir)) {
  fs.mkdirSync(schemaTypesDir, { recursive: true });
}

// Helper function to read the bootstrap types file and extract types with their properties
function extractBootstrapTypes() {
  if (!fs.existsSync(bootstrapTypesPath)) {
    return {};
  }

  const content = fs.readFileSync(bootstrapTypesPath, 'utf-8');
  const bootstrapTypes = {};

  // Extract interfaces
  const interfaceRegex = /export\s+interface\s+([A-Za-z0-9_]+)\s*{([^}]*)}/gs;
  let match;
  
  while ((match = interfaceRegex.exec(content)) !== null) {
    const name = match[1];
    const body = match[2];
    
    // Extract properties
    const properties = [];
    const propertyRegex = /\s*([A-Za-z0-9_]+)(\??)\s*:\s*([^;]+);/g;
    let propMatch;
    
    while ((propMatch = propertyRegex.exec(body)) !== null) {
      properties.push({
        name: propMatch[1],
        optional: !!propMatch[2],
        type: propMatch[3].trim()
      });
    }
    
    bootstrapTypes[name] = {
      type: 'interface',
      properties
    };
  }
  
  // Extract enums
  const enumRegex = /export\s+enum\s+([A-Za-z0-9_]+)\s*{([^}]*)}/gs;
  
  while ((match = enumRegex.exec(content)) !== null) {
    const name = match[1];
    const body = match[2];
    
    // Extract values
    const values = [];
    const valueRegex = /\s*([A-Za-z0-9_]+)\s*=\s*["']([^"']+)["']/g;
    let valueMatch;
    
    while ((valueMatch = valueRegex.exec(body)) !== null) {
      values.push({
        name: valueMatch[1],
        value: valueMatch[2]
      });
    }
    
    bootstrapTypes[name] = {
      type: 'enum',
      values
    };
  }

  return bootstrapTypes;
}

try {
  // Read the generated schema (JSON or YAML)
  let schema;
  if (fs.existsSync(schemaJsonPath)) {
    console.log('üìÑ Found swagger.json, using it for type generation');
    const schemaContent = fs.readFileSync(schemaJsonPath, 'utf-8');
    schema = JSON.parse(schemaContent);
  } else if (fs.existsSync(schemaYamlPath)) {
    console.log('üìÑ Found swagger.yaml, converting to JSON for type generation');
    schema = YAML.load(schemaYamlPath);
    fs.writeFileSync(schemaJsonPath, JSON.stringify(schema, null, 2));
    console.log('üíæ Created swagger.json from YAML for future use');
  } else {
    console.error('‚ùå Error: No schema file found. Run generate-api-types.sh first.');
    process.exit(1);
  }

  // Extract schemas from OpenAPI spec
  const schemas = schema.components?.schemas || {};
  console.log('[sync-types.js] Found schemas:', Object.keys(schemas));

  // Load bootstrap types to use as fallbacks if schema definitions are incomplete
  const bootstrapTypes = extractBootstrapTypes();

  // Generate header with imports and initial types
  let output = `/**
 * API Types
 * 
 * This is the single source of truth for all API types used in Discura.
 * These types are generated from the OpenAPI schema (swagger.json)
 * which is derived from TSOA definitions in common/src/types/api.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Changes should be made in the source files in common/src/types/api, then run ./generate-api-types.sh
 */

`;

  // Add BotStatus enum directly since it might not be fully captured in the schema
  if (bootstrapTypes['BotStatus'] && bootstrapTypes['BotStatus'].type === 'enum') {
    output += `export enum BotStatus {\n`;
    for (const { name, value } of bootstrapTypes['BotStatus'].values) {
      output += `  ${name} = "${value}",\n`;
    }
    output += `}\n\n`;
  }

  // Add LLMProvider enum directly
  if (bootstrapTypes['LLMProvider'] && bootstrapTypes['LLMProvider'].type === 'enum') {
    output += `export enum LLMProvider {\n`;
    for (const { name, value } of bootstrapTypes['LLMProvider'].values) {
      output += `  ${name} = "${value}",\n`;
    }
    output += `}\n\n`;
  }

  // Add any nested types first to avoid reference errors
  const nestedTypes = [
    'LLMModelData', 
    'LLMCompletionMessage',
    'LLMCompletionResponseChoice', 
    'LLMCompletionResponseUsage',
    'UserResponseDto'
  ];

  // Define types that should be skipped (won't be generated as interfaces)
  const skipTypes = ['Record_string.any_'];

  // Helper function to determine if a schema seems incomplete
  function isIncompleteSchema(schemaData) {
    // Check if it's an empty object schema
    if (schemaData.type === 'object' && 
        (!schemaData.properties || Object.keys(schemaData.properties).length === 0)) {
      return true;
    }
    
    // Check if it contains placeholders in its description
    if (schemaData.description && 
        schemaData.description.includes('Placeholder') && 
        schemaData.description.includes('will be replaced')) {
      return true;
    }
    
    return false;
  }

  // Helper function to convert problematic types to proper TS syntax
  function sanitizeTypeName(typeName) {
    // Convert Record_string.any_ to Record<string, any>
    if (typeName === 'Record_string.any_') {
      return 'Record<string, any>';
    }
    return typeName;
  }

  // First generate the nested types that other types depend on
  for (const typeName of nestedTypes) {
    if (bootstrapTypes[typeName] && !skipTypes.includes(typeName)) {
      output += `export interface ${typeName} {\n`;
      
      if (bootstrapTypes[typeName].properties && bootstrapTypes[typeName].properties.length > 0) {
        for (const { name, type, optional } of bootstrapTypes[typeName].properties) {
          if (name !== '[key: string]') { // Skip generic index signature
            const sanitizedType = sanitizeTypeName(type);
            output += `  ${name}${optional ? '?' : ''}: ${sanitizedType};\n`;
          }
        }
      } else {
        output += `  // No properties available\n`;
        output += `  [key: string]: any;\n`;
      }
      
      output += `}\n\n`;
    }
  }

  // Process schemas to create TypeScript interfaces and enums
  for (const [name, schemaData] of Object.entries(schemas)) {
    // Skip types that were already generated as nested types or should be skipped
    if (nestedTypes.includes(name) || 
        name === 'BotStatus' || 
        name === 'LLMProvider' || 
        skipTypes.includes(name)) {
      continue;
    }
    
    // Check if the schema represents an enum (string type with an enum array)
    if (schemaData.type === 'string' && Array.isArray(schemaData.enum)) {
      console.log(`[sync-types.js] Generating enum: ${name}`);
      output += `export enum ${name} {\n`;
      
      // Use schema enum values if available
      if (schemaData.enum.length > 0) {
        for (const enumValue of schemaData.enum) {
          let memberName = String(enumValue).toUpperCase();
          memberName = memberName.replace(/[^A-Z0-9_]/g, '_');
          const validMemberName = /^[A-Z_][A-Z0-9_]*$/.test(memberName) ? memberName : `_${memberName}`;
          output += `  ${validMemberName} = "${enumValue}",\n`;
        }
      } 
      // Fall back to bootstrap enum values if schema is empty but bootstrap has values
      else if (bootstrapTypes[name] && bootstrapTypes[name].type === 'enum' && bootstrapTypes[name].values.length > 0) {
        console.log(`[sync-types.js] Using bootstrap values for enum ${name}`);
        for (const { name: valueName, value } of bootstrapTypes[name].values) {
          output += `  ${valueName} = "${value}",\n`;
        }
      } 
      // Provide a default empty enum value as last resort
      else {
        output += `  // No enum values available\n`;
      }
      
      output += '}\n\n';
    } else if (schemaData.type === 'object' || schemaData.properties) {
      console.log(`[sync-types.js] Generating interface: ${name}`);
      output += `export interface ${name} {\n`;
      
      // Check if the schema definition appears to be incomplete
      if (isIncompleteSchema(schemaData) && bootstrapTypes[name]) {
        // Use bootstrap properties if available
        console.log(`[sync-types.js] Schema for ${name} appears incomplete, using bootstrap properties`);
        
        if (bootstrapTypes[name].properties && bootstrapTypes[name].properties.length > 0) {
          for (const { name: propName, type: propType, optional } of bootstrapTypes[name].properties) {
            if (propName !== '[key: string]') { // Skip generic index signature
              output += `  ${propName}${optional ? '?' : ''}: ${propType};\n`;
            }
          }
        } else {
          output += `  // No properties available in bootstrap\n`;
          output += `  [key: string]: any;\n`;
        }
      } else if (schemaData.properties && Object.keys(schemaData.properties).length > 0) {
        // Use schema properties when available
        for (const [propName, propData] of Object.entries(schemaData.properties)) {
          const isRequired = schemaData.required?.includes(propName) ? '' : '?';
          let typeName = 'any';
          
          switch (propData.type) {
            case 'string':
              typeName = 'string';
              break;
            case 'number':
              typeName = 'number';
              break;
            case 'boolean':
              typeName = 'boolean';
              break;
            case 'integer':
              typeName = 'number';
              break;
            case 'array':
              if (propData.items?.type) {
                typeName = `${propData.items.type}[]`;
              } else if (propData.items?.$ref) {
                const refType = propData.items.$ref.split('/').pop();
                typeName = `${sanitizeTypeName(refType)}[]`;
              } else {
                typeName = 'any[]';
              }
              break;
            case 'object':
              if (propData.additionalProperties) {
                let valueType = 'any';
                if (propData.additionalProperties.type) {
                  valueType = propData.additionalProperties.type;
                } else if (propData.additionalProperties.$ref) {
                  valueType = propData.additionalProperties.$ref.split('/').pop();
                }
                typeName = `Record<string, ${valueType}>`;
              } else {
                typeName = 'Record<string, any>';
              }
              break;
            default:
              if (propData.$ref) {
                const refType = propData.$ref.split('/').pop();
                typeName = sanitizeTypeName(refType);
              } else if (propData.enum) {
                typeName = propData.enum.map(v => `"${v}"`).join(' | ');
              }
          }
          
          output += `  ${propName}${isRequired}: ${typeName};\n`;
        }
      } else {
        // If no properties are available even in bootstrap, create a generic index signature
        output += `  // No schema properties defined\n`;
        output += `  [key: string]: any;\n`;
      }
      
      output += '}\n\n';
    }
  }

  // Write the output to the API types file
  fs.writeFileSync(schemaTypesPath, output);
  console.log('‚úÖ API types synchronized successfully to common/src/schema/types.ts!');

} catch (error) {
  console.error('‚ùå Error syncing types:', error);
  console.error(error.stack);
  process.exit(1);
}