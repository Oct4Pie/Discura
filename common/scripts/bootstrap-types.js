#!/usr/bin/env node

/**
 * Type Bootstrap Script
 * 
 * This script creates a preliminary version of common/schema/types.ts with placeholder types.
 * It's used before running the TSOA generation to break circular dependencies.
 * 
 * The process:
 * 1. Scan common/src/types/api for @tsoaModel JSDoc comments
 * 2. Extract type names and generate placeholder definitions
 * 3. Write these to common/schema/types.ts
 * 4. Later, sync-types.js will replace these with proper definitions
 * 
 * This ensures that controllers can properly import from common/schema/types
 * while TSOA can still find all the original type definitions.
 */

const fs = require('fs');
const path = require('path');
const glob = require('glob');

// Get absolute paths to ensure correct resolution
const rootDir = path.resolve(__dirname, '../..');
const typesDir = path.join(rootDir, 'common/src/types/api');
const typesGlob = path.join(typesDir, '**/*.ts');
const outputPath = path.join(rootDir, 'common/src/schema/types.ts');

// Debug file path resolution
console.log(`Looking for API types in: ${typesDir}`);
console.log(`Using glob pattern: ${typesGlob}`);

// Ensure output directory exists
const outputDir = path.dirname(outputPath);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
  console.log(`Created schema directory: ${outputDir}`);
}

console.log('üîç Scanning common/src/types/api for @tsoaModel decorators...');

// Type placeholders we've found
const foundTypes = new Map();

// Regular expressions for matching type definitions
const enumRegex = /\/\*\*[\s\S]*?@tsoaModel[\s\S]*?\*\/\s*export\s+enum\s+([A-Za-z0-9_]+)[\s\S]*?{([\s\S]*?)}/g;
const interfaceRegex = /\/\*\*[\s\S]*?@tsoaModel[\s\S]*?\*\/\s*export\s+(interface|type)\s+([A-Za-z0-9_]+)(?:\s+{([\s\S]*?)}|[\s\S]*?{([\s\S]*?)})/g;

// Enhanced regex for property extraction from interfaces
const propertyRegex = /\s*([A-Za-z0-9_]+)(\??)\s*:\s*([A-Za-z0-9_<>\[\]|&{},\s'"]+);/g;

try {
  // First check if directory exists
  if (!fs.existsSync(typesDir)) {
    console.error(`‚ùå API Types directory not found: ${typesDir}`);
    // Create it if it doesn't exist
    fs.mkdirSync(typesDir, { recursive: true });
    console.log(`Created API types directory: ${typesDir}`);
  }

  // List files in directory to debug
  const dirFiles = fs.readdirSync(typesDir);
  console.log(`Files in API types directory: ${dirFiles.join(', ')}`);
  
  // Find all type definition files
  const files = glob.sync(typesGlob);
  
  if (files.length === 0) {
    console.log(`‚ö†Ô∏è No type files found with glob: ${typesGlob}`);
    // Continue anyway - we'll create an empty bootstrap file
    console.log(`Creating empty bootstrap types file to avoid build errors`);
  } else {
    console.log(`Found ${files.length} API type files`);
  }
  
  // Scan each file for @tsoaModel declarations
  files.forEach(file => {
    console.log(`Processing file: ${file}`);
    const content = fs.readFileSync(file, 'utf8');
    
    // Find enum definitions with enhanced regex to capture values
    let match;
    while ((match = enumRegex.exec(content)) !== null) {
      const enumName = match[1];
      const enumBody = match[2];
      console.log(`  Found enum: ${enumName}`);
      
      // Extract enum values
      const enumValues = [];
      const valueRegex = /([A-Za-z0-9_]+)\s*=\s*['"]([^'"]+)['"]/g;
      let valueMatch;
      
      while ((valueMatch = valueRegex.exec(enumBody)) !== null) {
        const name = valueMatch[1];
        const value = valueMatch[2];
        enumValues.push({ name, value });
      }
      
      foundTypes.set(enumName, {
        type: 'enum',
        values: enumValues.length > 0 ? enumValues : [{ name: 'PLACEHOLDER', value: 'placeholder' }],
      });
    }
    
    // Find interface definitions with enhanced regex for property capture
    while ((match = interfaceRegex.exec(content)) !== null) {
      const interfaceType = match[1]; // 'interface' or 'type'
      const interfaceName = match[2];
      const interfaceBody = match[3] || match[4] || '';
      
      console.log(`  Found interface: ${interfaceName}`);
      
      // Extract interface properties
      const properties = [];
      let propertyMatch;
      
      while ((propertyMatch = propertyRegex.exec(interfaceBody)) !== null) {
        const name = propertyMatch[1];
        const optional = !!propertyMatch[2]; // ? character indicates optional property
        const type = propertyMatch[3].trim();
        
        properties.push({ name, type, optional });
      }
      
      foundTypes.set(interfaceName, {
        type: 'interface',
        properties
      });
    }
  });
  
  // Generate type definition content
  let output = `/**
 * API Types (Bootstrap Version)
 * 
 * This is a preliminary version of the types file with placeholder definitions.
 * It's used to break circular dependencies during the generation process.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * It will be overwritten by the sync-types.js script.
 */

`;

  // Add placeholder definitions for each found type
  foundTypes.forEach((typeInfo, typeName) => {
    if (typeInfo.type === 'enum') {
      output += `/**
 * Placeholder enum for ${typeName}
 * This will be replaced with the actual definition by sync-types.js
 */
export enum ${typeName} {
`;
      // Add enum values with proper formatting
      if (typeInfo.values.length > 0) {
        typeInfo.values.forEach(({ name, value }) => {
          output += `  ${name} = "${value}",\n`;
        });
      } else {
        output += `  PLACEHOLDER = "placeholder",\n`;
      }
      output += `}\n\n`;
    } else if (typeInfo.type === 'interface') {
      output += `/**
 * Placeholder interface for ${typeName}
 * This will be replaced with the actual definition by sync-types.js
 */
export interface ${typeName} {
`;
      // Add interface properties with proper types
      if (typeInfo.properties && typeInfo.properties.length > 0) {
        typeInfo.properties.forEach(({ name, type, optional }) => {
          output += `  ${name}${optional ? '?' : ''}: ${type};\n`;
        });
      } else {
        output += `  [key: string]: any; // Placeholder property\n`;
      }
      output += `}\n\n`;
    }
  });

  // If no types were found, add some common placeholder types to prevent errors
  if (foundTypes.size === 0) {
    output += `/**
 * Placeholder types to prevent build errors when no API types are defined yet
 * These will be replaced by actual types once they are defined
 */
export interface PlaceholderType {
  id: string;
  [key: string]: any;
}

export enum PlaceholderEnum {
  PLACEHOLDER = "placeholder"
}

`;
  }

  // Write the output
  fs.writeFileSync(outputPath, output);
  console.log(`‚úÖ Created bootstrap types file with ${foundTypes.size} placeholder definitions`);
  
  // Create API index file for TSOA type resolution
  createOrUpdateApiIndex();
  
} catch (error) {
  console.error('‚ùå Error bootstrapping types:', error);
  console.error(error.stack);
  process.exit(1);
}

// The critical additional step - create an index.ts in common/src/types/api 
// that re-exports all types by scanning the directory
function createOrUpdateApiIndex() {
  console.log('üîÑ Creating API index file to ensure TSOA can find all types...');
  
  try {
    const apiDir = path.join(rootDir, 'common/src/types/api');
    const apiIndexPath = path.join(apiDir, 'index.ts');
    const apiFiles = fs.readdirSync(apiDir).filter(file => 
      file.endsWith('.ts') && file !== 'index.ts'
    );
    
    let indexContent = `/**
 * API Types Index
 * 
 * This file is auto-generated by bootstrap-types.js
 * It re-exports all API types to ensure they're accessible to TSOA
 * during the generation process.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 */

`;
    
    for (const file of apiFiles) {
      const moduleName = file.replace('.ts', '');
      indexContent += `export * from './${moduleName}';\n`;
    }
    
    fs.writeFileSync(apiIndexPath, indexContent);
    console.log(`‚úÖ API index file created/updated at ${apiIndexPath}`);
    
    return true;
  } catch (error) {
    console.error('‚ùå Error creating API index file:', error);
    return false;
  }
}