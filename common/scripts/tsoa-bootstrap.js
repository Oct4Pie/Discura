#!/usr/bin/env node

/**
 * TSOA Bootstrap Script
 * 
 * This script runs TSOA generation with proper TypeScript configuration to handle
 * cross-package imports without needing temporary module files.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const glob = require('glob');

// Get paths
const rootDir = path.resolve(__dirname, '../..');
const commonDir = path.join(rootDir, 'common');
const tsoaJsonPath = path.join(commonDir, 'tsoa.json');
const minimalTsConfigPath = path.join(commonDir, 'tsconfig.tsoa.json'); 

// Ensure necessary directories exist
const schemaDir = path.join(commonDir, 'src/schema');
const routesDir = path.join(commonDir, 'src/routes');
const tempDir = path.join(commonDir, 'src/temp');

if (!fs.existsSync(schemaDir)) {
  fs.mkdirSync(schemaDir, { recursive: true });
  console.log(`Created schema directory: ${schemaDir}`);
}

if (!fs.existsSync(routesDir)) {
  fs.mkdirSync(routesDir, { recursive: true });
  console.log(`Created routes directory: ${routesDir}`);
}

if (!fs.existsSync(tempDir)) {
  fs.mkdirSync(tempDir, { recursive: true });
  console.log(`Created temporary directory: ${tempDir}`);
}

// Flag to control cleanup - TRUE to keep temporary files for debugging
const DEBUG_MODE = false;
const SKIP_CLEANUP = DEBUG_MODE;

// Generate command using proper configuration
function getTsoaCommand(type) {
  const validTypes = ['spec', 'routes'];
  if (!validTypes.includes(type)) {
    throw new Error(`Invalid TSOA command type: ${type}. Must be one of: ${validTypes.join(', ')}`);
  }

  // Use relative paths since we're executing from common directory
  return `npx tsoa ${type} -c tsoa.json --tsconfig tsconfig.tsoa.json`;
}

// Create a temporary reference file that imports directly from the API source files
function createControllerTypesHelper() {
  console.log('Creating controller types helper by scanning source types...');
  
  // Make debug directory for storing source files
  const debugDir = path.join(tempDir, 'debug');
  if (!fs.existsSync(debugDir)) {
    fs.mkdirSync(debugDir, { recursive: true });
  }
  
  // Read existing types from source files
  const apiTypesDir = path.join(commonDir, 'src/types/api');
  const apiTypeFiles = glob.sync(path.join(apiTypesDir, '**/*.ts'));
  
  // Copy all source type files to the debug directory for inspection
  if (DEBUG_MODE) {
    apiTypeFiles.forEach(file => {
      const fileName = path.basename(file);
      const debugFilePath = path.join(debugDir, fileName);
      fs.copyFileSync(file, debugFilePath);
    });
    console.log(`Copied source API type files to ${debugDir} for debugging`);
  }
  
  // Create a direct reference file in the types/api directory for TSOA
  // This is a critical step - it helps TSOA find the types with the @tsoaModel decorator
  const tsoaRefPath = path.join(commonDir, 'src/types/api/tsoa-reference.ts');
  try {
    let refContent = `/**
 * TSOA TYPE REFERENCE FILE
 * This file is auto-generated by tsoa-bootstrap.js
 * It provides direct access to all API types with their @tsoaModel decorators
 * DO NOT EDIT THIS FILE - it will be deleted after generation
 */

`;
    
    // Add re-exports for all API type files
    apiTypeFiles.forEach(file => {
      if (!file.endsWith('index.ts') && !file.includes('tsoa-reference')) {
        const relativePath = './' + path.basename(file, '.ts');
        refContent += `export * from '${relativePath}';\n`;
      }
    });
    
    fs.writeFileSync(tsoaRefPath, refContent);
    console.log(`Created TSOA direct reference file at ${tsoaRefPath}`);
    if (DEBUG_MODE) {
      fs.copyFileSync(tsoaRefPath, path.join(debugDir, 'tsoa-reference.ts'));
    }
  } catch (error) {
    console.error('Error creating TSOA reference file:', error);
  }
  
  // Create a helper file that imports all actual types from source files
  const helperPath = path.join(commonDir, 'src/controllers/tsoa-helper.ts');
  
  try {
    let helperContent = `
/**
 * TSOA CONTROLLER HELPER
 * This file is auto-generated to help TSOA find all types referenced in controllers.
 * It will be deleted after TSOA generation completes.
 */

// Import from the direct reference file which re-exports all types with their @tsoaModel decorators
export * from '../types/api/tsoa-reference';
`;
    
    // Write helper file
    fs.writeFileSync(helperPath, helperContent);
    console.log(`Created controller types helper at ${helperPath}`);
    
    // Save a copy of the helper file to the debug directory
    if (DEBUG_MODE) {
      fs.copyFileSync(helperPath, path.join(debugDir, 'tsoa-helper.ts'));
    }
    
    return true;
  } catch (error) {
    console.error('Error creating controller types helper:', error);
    return false;
  }
}

// Create a tsoa-types-debug.ts file that contains all API type definitions for debugging
function createDebugTypesFile() {
  const debugTypesPath = path.join(tempDir, 'tsoa-types-debug.ts');
  const apiTypesDir = path.join(commonDir, 'src/types/api');
  const apiTypeFiles = glob.sync(path.join(apiTypesDir, '**/*.ts'));
  
  console.log('Creating debug types file with all type definitions...');
  
  try {
    let debugContent = `
/**
 * DEBUG TYPES FILE
 * This file contains all API type definitions for debugging TSOA issues.
 * It will show which types are available during compilation.
 */

`;

    // Read all the API type files and concatenate their content into one file
    apiTypeFiles.forEach(file => {
      if (!file.endsWith('index.ts')) {
        const content = fs.readFileSync(file, 'utf-8');
        const filename = path.basename(file);
        debugContent += `\n// ---------- From ${filename} ----------\n\n`;
        debugContent += content + '\n';
      }
    });
    
    // Add bootstrap types too
    const schemaTypesPath = path.join(commonDir, 'src/schema/types.ts');
    if (fs.existsSync(schemaTypesPath)) {
      const schemaContent = fs.readFileSync(schemaTypesPath, 'utf-8');
      debugContent += `\n// ---------- From schema/types.ts (Bootstrap) ----------\n\n`;
      debugContent += schemaContent + '\n';
    }
    
    fs.writeFileSync(debugTypesPath, debugContent);
    console.log(`Created debug types file at ${debugTypesPath}`);
    return true;
  } catch (error) {
    console.error('Error creating debug types file:', error);
    return false;
  }
}

// Add temporary patch to ensure controllers can import types correctly during TSOA generation
function temporarilyPatchControllerImports() {
  try {
    const controllersDir = path.join(commonDir, 'src/controllers');
    const controllers = fs.readdirSync(controllersDir).filter(file => 
      file.endsWith('.ts') && !file.startsWith('tsoa-')
    );
    const backupDir = path.join(commonDir, 'src/controllers_backup');
    
    // Create backup directory if it doesn't exist
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }
    
    // Create debug directory for patched controller copies
    const debugDir = path.join(tempDir, 'debug_controllers');
    if (!fs.existsSync(debugDir) && DEBUG_MODE) {
      fs.mkdirSync(debugDir, { recursive: true });
    }
    
    // Create a debug types file with all API type definitions
    if (DEBUG_MODE) {
      createDebugTypesFile();
    }
    
    // Create helper file with all types imported from source
    createControllerTypesHelper();
    
    // Store original controllers for rollback
    controllers.forEach(controller => {
      const controllerPath = path.join(controllersDir, controller);
      const backupPath = path.join(backupDir, controller);
      
      // Backup the original file
      fs.copyFileSync(controllerPath, backupPath);
      
      // Read controller content
      const content = fs.readFileSync(controllerPath, 'utf-8');
      
      // Replace imports from 'common/schema/types' with direct import from helper
      let patchedContent = content.replace(
        /import\s+{([^}]+)}\s+from\s+['"]common\/schema\/types['"]/g,
        'import { $1 } from "./tsoa-helper"'
      );
      
      // Write patched content back
      fs.writeFileSync(controllerPath, patchedContent);
      console.log(`Patched imports in ${controller}`);
      
      // Save a copy of the patched controller for debugging
      if (DEBUG_MODE) {
        fs.copyFileSync(controllerPath, path.join(debugDir, controller));
      }
    });
    
    return backupDir;
  } catch (error) {
    console.error('Error patching controller imports:', error);
    throw error;
  }
}

// Clean up temporary files
function cleanupTemporaryFiles() {
  if (SKIP_CLEANUP) {
    console.log('Skipping cleanup of temporary files for debugging purposes');
    return;
  }
  
  console.log('Cleaning up temporary files...');
  
  // Delete helper file in controllers directory
  const helperPath = path.join(commonDir, 'src/controllers/tsoa-helper.ts');
  if (fs.existsSync(helperPath)) {
    fs.unlinkSync(helperPath);
    console.log(`Deleted temporary helper file: ${helperPath}`);
  } else {
    console.log(`Warning: Helper file not found at ${helperPath}`);
  }
  
  // Delete the reference file in types/api
  const tsoaRefPath = path.join(commonDir, 'src/types/api/tsoa-reference.ts');
  if (fs.existsSync(tsoaRefPath)) {
    fs.unlinkSync(tsoaRefPath);
    console.log(`Deleted temporary reference file: ${tsoaRefPath}`);
  } else {
    console.log(`Warning: Reference file not found at ${tsoaRefPath}`);
  }
  
  // Try to remove temporary directory
  try {
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
      console.log(`Removed temporary directory: ${tempDir}`);
    }
  } catch (error) {
    // Ignore errors if directory isn't empty
    console.error('Error cleaning up temp directory:', error.message);
  }
  
  console.log('Temporary files cleaned up');
}

// Restore original controller files
function restoreControllerImports(backupDir) {
  try {
    const controllersDir = path.join(commonDir, 'src/controllers');
    
    if (!fs.existsSync(backupDir)) {
      console.log('No backup directory found, nothing to restore');
      return;
    }
    
    // Always restore controllers regardless of DEBUG_MODE - fixes the restoration issue
    // We want to keep the helper file but we need to restore the imports
    console.log('Restoring original controller files...');
    
    const backups = fs.readdirSync(backupDir).filter(file => file.endsWith('.ts'));
    console.log(`Found ${backups.length} backup files to restore`);
    
    // Restore from backups
    backups.forEach(backup => {
      const backupPath = path.join(backupDir, backup);
      const controllerPath = path.join(controllersDir, backup);
      
      // Restore the original file
      fs.copyFileSync(backupPath, controllerPath);
      console.log(`Restored original file: ${backup}`);
      
      // Remove backup file
      fs.unlinkSync(backupPath);
    });
    
    // Only clean up temporary files if not in debug mode
    if (!SKIP_CLEANUP) {
      // Clean up temporary files
      cleanupTemporaryFiles();
    } else {
      console.log('Skipping temporary file cleanup due to DEBUG_MODE being enabled');
    }
    
    // Try to remove backup directory
    try {
      fs.rmdirSync(backupDir);
    } catch (rmError) {
      // Ignore error if directory isn't empty
    }
    
    console.log('Controller imports restored successfully');
  } catch (error) {
    console.error('Error restoring controller imports:', error);
    // Don't throw here, as we want to continue even if restoration fails
  }
}

// Check tsoa.json configuration
function checkTsoaConfiguration() {
  console.log('Checking tsoa.json configuration...');
  
  try {
    const tsoaConfigPath = path.join(commonDir, 'tsoa.json');
    if (!fs.existsSync(tsoaConfigPath)) {
      console.error('tsoa.json not found!');
      return false;
    }
    
    const tsoaConfig = JSON.parse(fs.readFileSync(tsoaConfigPath, 'utf8'));
    
    // Add modelsPathGlobs if not present or update to include our tsoa-reference.ts file
    if (!tsoaConfig.modelsPathGlobs || !Array.isArray(tsoaConfig.modelsPathGlobs) || 
        !tsoaConfig.modelsPathGlobs.includes("./src/types/api/tsoa-reference.ts")) {
      // Ensure modelsPathGlobs exists and is an array
      tsoaConfig.modelsPathGlobs = tsoaConfig.modelsPathGlobs || [];
      if (!Array.isArray(tsoaConfig.modelsPathGlobs)) {
        tsoaConfig.modelsPathGlobs = [tsoaConfig.modelsPathGlobs];
      }
      
      // Make sure both general glob pattern and our reference file are included
      if (!tsoaConfig.modelsPathGlobs.includes("./src/types/api/**/*.ts")) {
        tsoaConfig.modelsPathGlobs.push("./src/types/api/**/*.ts");
      }
      
      if (!tsoaConfig.modelsPathGlobs.includes("./src/types/api/tsoa-reference.ts")) {
        tsoaConfig.modelsPathGlobs.push("./src/types/api/tsoa-reference.ts");
      }
      
      fs.writeFileSync(tsoaConfigPath, JSON.stringify(tsoaConfig, null, 2));
      console.log('Updated tsoa.json with improved modelsPathGlobs configuration');
    }
    
    // Ensure JSDoc is enabled
    if (!tsoaConfig.jsdoc || !tsoaConfig.jsdoc.enabled) {
      tsoaConfig.jsdoc = tsoaConfig.jsdoc || {};
      tsoaConfig.jsdoc.enabled = true;
      fs.writeFileSync(tsoaConfigPath, JSON.stringify(tsoaConfig, null, 2));
      console.log('Enabled JSDoc in tsoa.json');
    }
    
    return true;
  } catch (error) {
    console.error('Error checking tsoa configuration:', error);
    return false;
  }
}

// Update tsconfig.tsoa.json to properly include all needed types
function updateTsoaTsConfig() {
  console.log('Updating tsconfig.tsoa.json...');
  
  try {
    const tsConfigPath = path.join(commonDir, 'tsconfig.tsoa.json');
    if (!fs.existsSync(tsConfigPath)) {
      console.error('tsconfig.tsoa.json not found!');
      return false;
    }
    
    const tsConfig = JSON.parse(fs.readFileSync(tsConfigPath, 'utf8'));
    
    // Update paths for better type resolution
    tsConfig.compilerOptions = tsConfig.compilerOptions || {};
    tsConfig.compilerOptions.paths = tsConfig.compilerOptions.paths || {};
    
    // Add explicit paths for schema types to help TSOA find them
    tsConfig.compilerOptions.paths["common/schema/types"] = ["./src/schema/types.ts"];
    tsConfig.compilerOptions.paths["common/src/schema/types"] = ["./src/schema/types.ts"];
    tsConfig.compilerOptions.paths["common/src/types/api/*"] = ["./src/types/api/*"];
    
    fs.writeFileSync(tsConfigPath, JSON.stringify(tsConfig, null, 2));
    console.log('Updated tsconfig.tsoa.json with necessary paths');
    
    return true;
  } catch (error) {
    console.error('Error updating tsconfig.tsoa.json:', error);
    return false;
  }
}

// Export functions for the main script to use
module.exports = {
  generateSpec: function() {
    console.log('ðŸ”¨ Generating API schema using TSOA...');
    const command = getTsoaCommand('spec');
    console.log(`Executing in ${commonDir}: ${command}`);

    let backupDir = null;
    try {
      // Make sure TSOA configuration is valid
      checkTsoaConfiguration();
      updateTsoaTsConfig();
      
      // Patch controller imports
      backupDir = temporarilyPatchControllerImports();
      
      // Execute from commonDir
      process.chdir(commonDir);
      execSync(command, { stdio: 'inherit' });
    } catch (error) {
      console.error('Failed to generate API schema:', error);
      throw error;
    } finally {
      // Always restore the original controller imports
      if (backupDir) {
        restoreControllerImports(backupDir);
      }
      
      // Return to original directory
      process.chdir(rootDir);
    }
  },
  
  generateRoutes: function() {
    console.log('ðŸ”¨ Generating routes with TSOA...');
    const command = getTsoaCommand('routes');
    console.log(`Executing in ${commonDir}: ${command}`);
    
    let backupDir = null;
    try {
      // Make sure TSOA configuration is valid
      checkTsoaConfiguration();
      updateTsoaTsConfig();
      
      // Patch controller imports
      backupDir = temporarilyPatchControllerImports();
      
      // Execute from commonDir
      process.chdir(commonDir);
      execSync(command, { stdio: 'inherit' });
    } catch (error) {
      console.error('Failed to generate routes:', error);
      throw error;
    } finally {
      // Always restore the original controller imports
      if (backupDir) {
        restoreControllerImports(backupDir);
      }
      
      // Return to original directory
      process.chdir(rootDir);
    }
  }
};

// If script is run directly, show usage instructions
if (require.main === module) {
  console.log(`
Usage: This script is meant to be imported from generate-api-types.sh
  
To generate the API spec: 
  const bootstrap = require('./tsoa-bootstrap.js');
  bootstrap.generateSpec();
  
To generate the API routes:
  bootstrap.generateRoutes();
`);
}